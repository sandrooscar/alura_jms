*** AULA01

MOM - middleware orientado a mensagem (MOM (Message Oriented Middleware))

middleware famoso no mundo Java - ActiveMQ

http://activemq.apache.org/version-5-getting-started
ActiveMQ

* CONCEITO
Identificamos duas vantagens:

1) As mensagens serão entregues assincronamente.

2) O sistema que recebe a mensagem está arquiteturalmente desacoplado do sistema que envia as mensagens.

O MOM (ou Broker) é um lugar onde os dados ficam salvos temporariamente, até o outro sistema conseguir processá-los. O MOM garante a entrega em algum momento e ajuda assim a lidar com indisponibilidade de sistemas e picos de processamento.

Em geral, a mensageria é um estilo de integração alternativo ao modelo RPC (Remote Procedure Call). O RPC (como o SOAP ou REST) é síncrono e acoplado pela interface de uso.

Como é importante saber as vantagens, também devemos conhecer as desvantagens. Como desvantagem principal podemos dizer que usando um MOM temos que manter mais um componente arquitetural. Nosso sistema fica mais complexo e mais custoso de manter.

Os brokers são uma parte fundamental na integração de sistemas e existem vários no mercado, alguns de grandes fornecedores. Exemplos populares são o RabbitMQ e o WebsphereMQ e, claro, o nosso ActiveMQ.

Alguns até estão disponíveis na nuvem como Amazon SQS e iron.io.

** App de consumo de mensagens
java -cp activemq-all-5.12.0.jar;aula-jms.jar br.com.caelum.TesteMensageria consome

** Os 4 estilos de integração
Os 4 estilos são:

Mensageria
RPC
Banco de dados compartilhado
Troca de arquivos

*** AULA02

** Configuração jndi.properties
https://activemq.apache.org/jndi-support.html


InitialContext initialContext = new InitialContext();

** InitialContext porp padrão procura automaticamente o jndi.properties no classpath do projeto.

- ConnectionFactory factory = (ConnectionFactory) context.lookup("ConnectionFactory");
O lookup é feito através da classe InitialContext que por sua vez se baseia no arquivo de configuração jndi.properties

** O arquivo jndi.properties e a classe InitialContext fazem parte de um outro padrão JavaEE, o JNDI (Java Naming e Diretory Service).

** O lookup é uma operação muito comum em ambientes JavaEE para descobrir ou pegar um recurso que o servidor disponibiliza. Dependendo do servidor os recursos podem variar muito. Por exemplo, usando um servidor de aplicação, podemos pegar configurações de segurança, pool de conexão, gerenciadores de transação ou caches, etc.
No nosso caso o servidor ou Middelware é o ActiveMQ e ele automaticamente disponibiliza a ConnectionFactory. O ActiveMQ não é um servidor de aplicação e sim um Message Broker.

** A Session no JMS abstrai o trabalho transacional e confirmação do recebimento da mensagem. Além disso, também serve para produzir o MessageConsumer! É um objeto todo poderoso que criamos a partir da conexão:

Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);

O primeiro parâmetro do método createSession define se queremos usar o tratamento da transação como explícito. Como colocamos false, não é preciso chamar session.commit() ou session.rollback(). Faremos ainda mais exercícios com estes parâmetros para entender melhor o comportamento transacional da Session.

O Session.AUTO_ACKNOWLEDGE diz que queremos automaticamente (através da Session) confirmar o recebimento da mensagem JMS. Também há outras configurações disponíveis que iremos testar mais para frente.

** Qual é a ordem correta das classes envolvidas para construir um MessageConsumer?
Tudo começa com a ConnectionFactory que pegamos através do InitalContext. A fábrica cria a Connection que por sua vez instancia a Session. A Session é responsável por criar o MessageConsumer.

** documentacao
https://docs.oracle.com/javaee/5/api/javax/jms/Destination.html
https://docs.oracle.com/javaee/7/api/javax/jms/MessageConsumer.html#receive-long-

** Objeto especifico Queue - DESVANTAGEM
Normalmente usa-se as interfaces mais genéricas que funcionam com qualquer destino, não só Queue. Como veremos existem outros destinos.

Além disso, a interface QueueReceiver só possui um método a mais, o getQueueName() que é pouco útil.

Queue q = receiver.getQueueName(); //única diferença entre MessageConsumer e QueueReceiver

** Para saber mais: JMS 2.0

Estamos usando o JMS na versão 1.1 mas já existe uma atualização do padrão para a versão 2.0 que faz parte do Java EE 7.

No entanto, a grande maioria dos MOMs no mercado trabalham ainda com essa versão 1.1. Com ActiveMQ isso não é diferente e tudo funciona ainda com JMS 1.1.

Vimos os passos para criar um MessageConsumer com JMS 1.1:

ConnectionFactory -> Connection  -> Session -> MessageConsumer
No JMS 2.0 o desenho seria um pouco mais simples pois foi introduzido uma nova interface JMSContext que combina o trabalho da Connection e Session:

ConnectionFactory -> JMSContext -> JMSConsumer

Segue também um artigo no blog da Caelum sobre o novo padrão JMS 2.0:

http://blog.caelum.com.br/a-nova-api-do-jms-2-0-no-java-ee-7/

***AULA03

- A interface é MessageListener, inclusive o método do consume que o associa a um objeto que implementa essa interface é setMessageListener. Não é incomum passarmos como parâmetro para o método uma classe anônima, poupando assim a criação de mais uma classe. Criando uma classe ou usando uma classe a anônima, é o método onMessage que precisamos implementar.

- O JMS segue o mesmo padrão de projeto Observer! A diferença é que JMS é remoto ou distribuído. Ou seja, no padrão Observer originalmente descrito no livro GOF, tudo acontece na memória, o Observer desacopla objetos. Com JMS, a comunicação entre Producer e Consumer é remota, desacoplamento arquitetural.

Para fazer a comparação com o exemplo apresentado na pergunta: O botão seria um produtor de mensagem (ainda não criamos um produtor pelo JMS, apenas usamos o console de administração, isso vem no próximo capítulo). O ActionListener representa o MessageListener do mundo JMS e o ActionEvent seria a Message. Faz sentido?

Mais informações sobre este padrão Observer na página do Enterprise Integration Patterns:

http://www.enterpriseintegrationpatterns.com/patterns/messaging/ObserverJmsExample.html

***AULA04

- Quando é feita a distribuição, apenas um dos consumidores recebe a mensagem.
Quando trabalhamos com filas, as mensagens são entregues apenas para um consumidor. Se houver mais de um consumidor online a mensagem é entregue apenas para um dos (e nunca para os dois).

- Como mostrado no video faça o teste com dois consumidores online ao mesmo tempo. Envie várias mensagens de uma vez só (por exemplo 1000).

Nesse caso os dois consumidores competem um com ou outro pelo recebimento das mensagens. Nunca os dois consumidores vão receber a mesma mensagem.

Uma fila garante a entrega para um consumidor, ou seja, acontece um balanceamento das mensagens.

No mundo de padrões de integração esse modelo de entrega se chama Competing Consumers:

http://www.enterpriseintegrationpatterns.com/patterns/messaging/CompetingConsumers.html

** Trabalhando de forma distribuída
Editar o arquivo jndi.properties e alterar o valor da propriedade java.naming.provider.url colocando como valor o ip do MOM.

A propriedade java.naming.provider.url recebe o IP do MOM que queremos enviar/consumir mensagens. Além disso, essa propriedade faz parte do arquivo jndi.properties.

** (Opcional) Criando um QueueBrowser
- Dependendo da nossa aplicação, podemos precisar apenas checar (monitoramento) as mensagens que chegaram para uma determinada fila sem consumi-la. Ou seja, apenas queremos ver sem tirá-las da fila. Para isso podemos usar um componente do JMS chamado QueueBrowser, usado para navegar sobre as mensagens sem consumi-las.

https://www.programcreek.com/java-api-examples/?api=javax.jms.QueueBrowser
https://docs.oracle.com/javaee/7/api/javax/jms/QueueBrowser.html

***AULA05
-Topics espalham a mensagem, ou seja, transmitem a mensagem oara quem quer ouvir
-Na Aba tópics do activeMQ driar um novo tópico
-Se utilizarmos o codigo do consumidor mudando apenas o nome do lookup, o sistema só receberá a mensagem quando estiver online;
-O produtor é praticamente o mesmo, mudando apenas no nome do lookup
-no tópico é necessário identificação para receber a mensagems mesmo quando o sistema estiver offline
-Se tivermos consumidores identificados (assinaturas duráveis) o tópico vai guardar a mensagem até a entrega acontecer.

**Utilização do Topic
-Nós devemos identificar uma conexão com o método setClientId("clientId"), por exemplo:

connection.setClientID("comercial");
e identificar o assinatura (o consumidor) com o método createDurableSubscriber(topico,"nomeAssinatura"):

MessageConsumer consumer = session.createDurableSubscriber(topico, "assinatura");

-Assinaturas duráveis só existem para tópicos. Uma assinatura durável é nada mais do que um consumidor de um tópico que se identificou. Ou seja, o tópico sabe da existência desse consumidor.


